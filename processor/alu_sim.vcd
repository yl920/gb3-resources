$date
	Fri May 30 14:23:30 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module alu_sim $end
$var wire 1 ! Branch_Enable $end
$var wire 7 " AluCtl_wire [6:0] $end
$var wire 32 # ALUOut [31:0] $end
$var reg 32 $ A [31:0] $end
$var reg 32 % B [31:0] $end
$var reg 4 & FuncCode [3:0] $end
$var reg 1 ' MEM_fwd1_reg $end
$var reg 1 ( MEM_fwd2_reg $end
$var reg 32 ) MEM_result [31:0] $end
$var reg 7 * Opcode [6:0] $end
$var reg 1 + WB_fwd1_reg $end
$var reg 1 , WB_fwd2_reg $end
$var reg 32 - WB_result [31:0] $end
$var reg 1 . clk $end
$var reg 1 / rst $end
$scope module aluCtrl_inst $end
$var wire 4 0 FuncCode [3:0] $end
$var wire 7 1 Opcode [6:0] $end
$var reg 7 2 ALUCtl [6:0] $end
$upscope $end
$scope module alu_inst $end
$var wire 32 3 A [31:0] $end
$var wire 7 4 ALUctl [6:0] $end
$var wire 32 5 B [31:0] $end
$var wire 1 ' MEM_fwd1_reg $end
$var wire 1 ( MEM_fwd2_reg $end
$var wire 32 6 MEM_result [31:0] $end
$var wire 1 + WB_fwd1_reg $end
$var wire 1 , WB_fwd2_reg $end
$var wire 32 7 WB_result [31:0] $end
$var wire 1 . clk $end
$var wire 1 / rst $end
$var wire 32 8 sub_result [31:0] $end
$var wire 32 9 add_result [31:0] $end
$var wire 32 : B_neg [31:0] $end
$var wire 32 ; B_fwd [31:0] $end
$var wire 32 < A_fwd [31:0] $end
$var reg 32 = ALUOut [31:0] $end
$var reg 7 > ALUctl_d1 [6:0] $end
$var reg 7 ? ALUctl_d2 [6:0] $end
$var reg 32 @ A_d1 [31:0] $end
$var reg 32 A A_d2 [31:0] $end
$var reg 32 B B_d1 [31:0] $end
$var reg 32 C B_d2 [31:0] $end
$var reg 32 D B_neg_d1 [31:0] $end
$var reg 32 E B_neg_d2 [31:0] $end
$var reg 1 ! Branch_Enable $end
$var reg 32 F add_result_d1 [31:0] $end
$var reg 32 G sub_result_d1 [31:0] $end
$scope module add_unit $end
$var wire 1 . clk $end
$var wire 32 H input1 [31:0] $end
$var wire 32 I input2 [31:0] $end
$var wire 1 / rst $end
$var reg 32 J out [31:0] $end
$var reg 32 K stage1_sum [31:0] $end
$upscope $end
$scope module sub_unit $end
$var wire 1 . clk $end
$var wire 32 L input1 [31:0] $end
$var wire 32 M input2 [31:0] $end
$var wire 1 / rst $end
$var reg 32 N out [31:0] $end
$var reg 32 O stage1_sum [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
b0 5
b1111 4
b0 3
b1111 2
b0 1
b0 0
1/
0.
b0 -
0,
0+
b0 *
b0 )
0(
0'
b0 &
b0 %
b0 $
b0 #
b1111 "
0!
$end
#1
1.
#2
b11111111111111111111111110101011 :
b1010101 ;
b1111 <
b0 "
b0 2
b0 4
0.
b110011 *
b110011 1
b111 &
b111 0
b1010101 %
b1010101 5
b1111 $
b1111 3
0/
#3
b11111111111111111111111110101011 D
b11111111111111111111111110101011 M
b1010101 B
b1010101 I
b1111 @
b1111 H
b1111 L
1.
#4
0.
#5
b11111111111111111111111110101011 E
b1010101 C
b1111 A
b11111111111111111111111110111010 O
b1100100 K
1.
#6
b1 "
b1 2
b1 4
0.
b110 &
b110 0
#7
b1100100 9
b1100100 J
b11111111111111111111111110111010 8
b11111111111111111111111110111010 N
b1 >
b101 #
b101 =
1.
#8
0.
#9
b11111111111111111111111110111010 G
b1100100 F
b1 ?
1.
#10
b11111111111111111111111111111001 :
b111 ;
b10011100010000 <
b10 "
b10 2
b10 4
0.
b0 &
b0 0
b111 %
b111 5
b10011100010000 $
b10011100010000 3
#11
b10 >
b11111111111111111111111111111001 D
b11111111111111111111111111111001 M
b111 B
b111 I
b10011100010000 @
b10011100010000 H
b10011100010000 L
b1011111 #
b1011111 =
1.
#12
0.
#13
b10 ?
b11111111111111111111111111111001 E
b111 C
b10011100010000 A
b10011100001001 O
b10011100010111 K
1.
#14
b110 "
b110 2
b110 4
0.
b1000 &
b1000 0
#15
b10011100010111 9
b10011100010111 J
b10011100001001 8
b10011100001001 N
b110 >
b1100100 #
b1100100 =
1.
#16
0.
#17
b10011100001001 G
b10011100010111 F
b110 ?
1.
#18
b11111111111111111111111111111110 :
b10 ;
b0 <
b111 "
b111 2
b111 4
0.
b10 &
b10 0
b10 %
b10 5
b0 $
b0 3
#19
b111 >
b11111111111111111111111111111110 D
b11111111111111111111111111111110 M
b10 B
b10 I
b0 @
b0 H
b0 L
b10011100001001 #
b10011100001001 =
1.
#20
0.
#21
b111 ?
b11111111111111111111111111111110 E
b10 C
b0 A
b11111111111111111111111111111110 O
b10 K
1.
#22
b10000 <
b11 "
b11 2
b11 4
0.
b101 &
b101 0
b10000 $
b10000 3
#23
b10 9
b10 J
b11111111111111111111111111111110 8
b11111111111111111111111111111110 N
b11 >
b10000 @
b10000 H
b10000 L
b1 #
b1 =
1.
#24
0.
#25
b11111111111111111111111111111110 G
b10 F
b11 ?
b10000 A
b1110 O
b10010 K
1.
#26
b11111111111111111111111111111111 :
b1 ;
b1000 <
b100 "
b100 2
b100 4
0.
b1101 &
b1101 0
b1 %
b1 5
b1000 $
b1000 3
#27
b10010 9
b10010 J
b1110 8
b1110 N
b100 >
b11111111111111111111111111111111 D
b11111111111111111111111111111111 M
b1 B
b1 I
b1000 @
b1000 H
b1000 L
b100 #
b100 =
1.
#28
0.
#29
b1110 G
b10010 F
b100 ?
b11111111111111111111111111111111 E
b1 C
b1000 A
b111 O
b1001 K
1.
#30
b11111111111111111111111111111110 :
b10 ;
b10 <
b101 "
b101 2
b101 4
0.
b1 &
b1 0
b10 %
b10 5
b10 $
b10 3
#31
b1001 9
b1001 J
b111 8
b111 N
b101 >
b11111111111111111111111111111110 D
b11111111111111111111111111111110 M
b10 B
b10 I
b10 @
b10 H
b10 L
1.
#32
0.
#33
b111 G
b1001 F
b101 ?
b11111111111111111111111111111110 E
b10 C
b10 A
b0 O
b100 K
1.
#34
b11111111111111111111111100000001 :
b11111111 ;
b1010101 <
b1000 "
b1000 2
b1000 4
0.
b100 &
b100 0
b11111111 %
b11111111 5
b1010101 $
b1010101 3
#35
b100 9
b100 J
b0 8
b0 N
b1000 >
b11111111111111111111111100000001 D
b11111111111111111111111100000001 M
b11111111 B
b11111111 I
b1010101 @
b1010101 H
b1010101 L
b1000 #
b1000 =
1.
#36
0.
#37
b0 G
b100 F
b1000 ?
b11111111111111111111111100000001 E
b11111111 C
b1010101 A
b11111111111111111111111101010110 O
b101010100 K
1.
#38
0.
